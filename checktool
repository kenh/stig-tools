#!/usr/bin/perl
#
# Simple tool for manipulating STIG checklists
#

use XML::Simple;
use Data::Dumper;

if ($#ARGV < 0) {
	usage();
}

if ($ARGV[0] eq 'check') {
	$check = 1;
} elsif ($ARGV[0] eq 'import') {
	$import = 1;
} else {
	usage();
}

if ($check || $import) {
	if ($#ARGV != 2) {
		usage();
	}
	$oldcheck = XMLin($ARGV[1]);
	$newcheck = XMLin($ARGV[2]);
}

foreach $rule (@{$oldcheck->{'VULN'}}) {
	my $rulever = find_rulever($rule);
	my @newrule = grep(find_rulever($_) eq $rulever,
			   @{$newcheck->{'VULN'}});

	die "newrule elements was $#newrule, when it should be 0 or -1\n"
		if $#newrule > 0;

	if ($#newrule < 0) {
		print "Rule $rulever removed from newer STIG\n";
	} else {
		if (! comprule($rule, $newrule[0])) {
			print "Rule $rulever changed in newer STIG\n";
		}
	}
}

foreach $rule (@{$newcheck->{'VULN'}}) {
	my $rulever = find_rulever($rule);
	my @oldrule = grep(find_rulever($_) eq $rulever,
			   @{$oldcheck->{'VULN'}});

	if ($#oldrule < 0) {
		print "Rule $rulever added to newer STIG\n";
	}

	die "oldrule elements was $#oldrule, when it should be 0 or -1\n"
		if $#oldrule > 0;
}

exit 0;

sub find_rulever {
	my $vuln = shift(@_);

	my @attr = grep($_->{'VULN_ATTRIBUTE'} eq 'Rule_Ver',
			@{$vuln->{'STIG_DATA'}});

	die "Internal error: attributes matching Rule_ver was $#attr\n"
				if ($#attr != 0);

	return $attr[0]->{'ATTRIBUTE_DATA'};
}

sub usage {
	print <<"EOF";
Usage:	$0 check old-checklist new-checklist
	$0 import old-checklist new-checklist
EOF
	exit 1;
}

sub comprule {
	my ($oldrule, $newrule) = @_;
	my @olddata = sort {$a->{'VULN_ATTRIBUTE'} cmp $b->{'VULN_ATTRIBUTE'}}
				@{$oldrule->{'STIG_DATA'}};
	my @newdata = sort {$a->{'VULN_ATTRIBUTE'} cmp $b->{'VULN_ATTRIBUTE'}}
				@{$newrule->{'STIG_DATA'}};
	my $oldattr, $newattr, $datatype;

	while ($oldattr = shift @olddata, $newattr = shift @newdata) {
		my $oldattrname = $oldattr->{'VULN_ATTRIBUTE'};
		my $newattrname = $newattr->{'VULN_ATTRIBUTE'};
		my $oldattrdata = $oldattr->{'ATTRIBUTE_DATA'};
		my $newattrdata = $newattr->{'ATTRIBUTE_DATA'};
		if ($oldattrname ne $newattrname) {
			print "Attributes do not match! $oldattrname vs ",
				"$newattrname\n";
			return 0;
		}

		#
		# With XML::Simple, if the node is empty it's a hash
		# reference.  So right now if $oldattrdata and $newattrdata
		# are not both scalars, we skip
		#

		if (($datatype = ref($oldattrdata)) ne ref($newattrdata)) {
			print "Non-equal data types for $oldattrname\n";
			return 0;
		}

		next if $datatype ne 'SCALAR';

		if ($oldattrdata ne $newattrdata) {
			print "Data for attribute $oldattrname does not ",
				"match\n";
			print "old: \"$oldattrdata\"\n";
			print "new: \"$newattrdata\"\n";
			my $mask = $oldattrdata ^ $newattrdata;
			while ($mask =~ /[^\0]/g) {
				print substr($oldattrname, $-[0], 1), ' ',
					substr($newattrname, $-[0], 1), ' ',
					$-[0], "\n";
			}
			return 0;
		}
	}

	if ($#newdata > -1) {
		print "Extra attributes in new STIG\n";
		return 0;
	}

	return 1;
}
