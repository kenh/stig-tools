#!/usr/bin/perl
#
# $Id: checktool,v 1.9 2018/04/30 18:46:38 kenh Exp kenh $
#
# Simple tool for manipulating STIG checklists
#
# This tool can be used for manipulating checklists produced by the
# STIG tool.  The basic idea is that once you fill in a checklist with the
# appropriate entries, you can use this tool to migrate all of your filled-in
# data to a new version of the checklist.
#
# There are three subcommands: "dump", "check", and "import".
#
# "dump" outputs the checklist XML structure using the Data::Dumper module.
# It is intended only to be used by people who have to debug or alter
# this tool.
#
# "check" is given an existing checklist and a new checklist generated from
# a new STIG release.  It will tell you what it thinks needs to change
# (rules added or removed, rules that have been changed).
#
# "import" will do everything that "check" does, except then copy over
# everything it can from the existing checklist to a new checklist specified
# on the command line.  If the rules are identical it will also copy over
# the "Status" (e.g. "Not a Finding"); the idea here is that if everything
# is the same there's no need to review it, but if things have changed
# a human should rewview the changes to make sure nothing needs to be changed
# in the response.
#
# Erci Stern: 4/30/2018 - added test to comprule for Check_Content_Ref
#                         attribute
#

use XML::Simple;
use Data::Dumper;

if ($#ARGV < 0) {
	usage();
}

if ($ARGV[0] eq 'check') {
	$check = 1;
} elsif ($ARGV[0] eq 'import') {
	$import = 1;
} elsif ($ARGV[0] eq 'dump') {
	$dump = 1;
} else {
	usage();
}

if (($check && $#ARGV != 2) || ($import && $#ARGV != 3) ||
    ($dump && $#ARGV != 1)) {
	usage();
}

if ($check || $import || $dump) {
	$oldcheck = XMLin($ARGV[1], ForceArray => 1, SuppressEmpty => '');
	if ($check || $import) {
		$newcheck = XMLin($ARGV[2], ForceArray => 1,
				  SuppressEmpty => '');
	}
}

if ($dump) {
	print Dumper($oldcheck);
	exit 0;
}

foreach $rule (@{$oldcheck->{'STIGS'}[0]->{'iSTIG'}[0]->{'VULN'}}) {
	my $rulever = find_rulever($rule);
	my @newrule = grep(find_rulever($_) eq $rulever,
			   @{$newcheck->{'STIGS'}[0]->{'iSTIG'}[0]->{'VULN'}});

	die "newrule elements was $#newrule, when it should be 0 or -1\n"
		if $#newrule > 0;

	if ($#newrule < 0) {
		print "Rule $rulever removed from newer STIG\n";
	} else {
		if (! comprule($rule, $newrule[0])) {
			print "Rule $rulever changed in newer STIG\n";
			copyrule($rule, $newrule[0], 0) if $import;
		} elsif ($rule->{'FINDING_DETAILS'}[0] eq '') {
			print "Rule $rulever missing Finding Details\n";
			copyrule($rule, $newrule[0], 0) if $import;
		} else {
			copyrule($rule, $newrule[0], 1) if $import;
		}
	}
}

foreach $rule (@{$newcheck->{'STIGS'}[0]->{'iSTIG'}[0]->{'VULN'}}) {
	my $rulever = find_rulever($rule);
	my @oldrule = grep(find_rulever($_) eq $rulever,
			   @{$oldcheck->{'STIGS'}[0]->{'iSTIG'}[0]->{'VULN'}});

	if ($#oldrule < 0) {
		print "Rule $rulever added to newer STIG\n";
	}

	die "oldrule elements was $#oldrule, when it should be 0 or -1\n"
		if $#oldrule > 0;
}

#
# Make sure we copy over asset data
#

if ($import) {
	my $asset = $oldcheck->{'ASSET'}[0];

	foreach $key (keys %{$asset}) {
		next if $key eq 'ASSET_VAL';
		$newcheck->{'ASSET'}[0]->{$key} = $asset->{$key};
	}

	#
	# For reasons I do not understand, with the latest version of the
	# STIG viewer it sometimes fails to parse the checklist it unless
	# the UUID is removed (it will generate a new one when it is saved).
	#

	my $index = 0;
	my $siarray = \@{$newcheck->{'STIGS'}[0]->{'iSTIG'}[0]->{'STIG_INFO'}[0]->{'SI_DATA'}};
	foreach $info (@$siarray) {
		if ($info->{'SID_NAME'}[0] eq 'uuid') {
			splice(@$siarray, $index, 1);
			last;
		}
		$index++;
	}

	XMLout($newcheck, RootName => 'CHECKLIST',
	       XMLDecl =>
		     '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>',
	       OutputFile => $ARGV[3]);
}

exit 0;

sub find_rulever {
	my $vuln = shift(@_);

	my @attr = grep($_->{'VULN_ATTRIBUTE'}[0] eq 'Rule_Ver',
			@{$vuln->{'STIG_DATA'}});

	die "Internal error: attributes matching Rule_ver was $#attr\n"
				if ($#attr != 0);

	return $attr[0]->{'ATTRIBUTE_DATA'}[0];
}

sub usage {
	print <<"EOF";
Usage:	$0 check old-checklist new-checklist
	$0 import old-checklist new-checklist output-checklist
	$0 dump checklist
EOF
	exit 1;
}

sub comprule {
	my ($oldrule, $newrule) = @_;
	my @olddata = sort {$a->{'VULN_ATTRIBUTE'}[0] cmp $b->{'VULN_ATTRIBUTE'}[0]}
				@{$oldrule->{'STIG_DATA'}};
	my @newdata = sort {$a->{'VULN_ATTRIBUTE'}[0] cmp $b->{'VULN_ATTRIBUTE'}[0]}
				@{$newrule->{'STIG_DATA'}};
	my $oldattr, $newattr, $datatype;

	while ($oldattr = shift @olddata, $newattr = shift @newdata) {
		my $oldattrname = $oldattr->{'VULN_ATTRIBUTE'}[0];
		my $newattrname = $newattr->{'VULN_ATTRIBUTE'}[0];
		my $oldattrdata = $oldattr->{'ATTRIBUTE_DATA'}[0];
		my $newattrdata = $newattr->{'ATTRIBUTE_DATA'}[0];
		if ($oldattrname ne $newattrname) {
			print "Attributes do not match! $oldattrname vs ",
				"$newattrname\n";
			return 0;
		}

		if ($oldattrdata ne $newattrdata) {
			if ($oldattrname eq 'STIGRef' ||
			    $oldattrname eq 'Check_Content_Ref') {
				print "Attr $oldattrname has changed, but ",
					"we are ignoring it\n";
			} else {
				print "Data for attribute $oldattrname does ",
					"not match\n";
				print "old: \"$oldattrdata\"\n";
				print "new: \"$newattrdata\"\n";
#			my $mask = $oldattrdata ^ $newattrdata;
#			while ($mask =~ /[^\0]/g) {
#				print substr($oldattrname, $-[0], 1), ' ',
#					substr($newattrname, $-[0], 1), ' ',
#					$-[0], "\n";
#			}
				return 0;
			}
		}
	}

	if ($#newdata > -1) {
		print "Extra attributes in new STIG\n";
		return 0;
	}

	return 1;
}

sub copyrule {
	my ($oldrule, $newrule, $copystatus) = @_;

	$newrule->{'FINDING_DETAILS'} = $oldrule->{'FINDING_DETAILS'};
	$newrule->{'STATUS'} = $oldrule->{'STATUS'} if $copystatus;
}
